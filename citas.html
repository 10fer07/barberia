<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Citas - Barber√≠a</title>
  <!-- Cliente JS de Supabase: se usa para autenticaci√≥n y consultas a la base -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <!-- Navegaci√≥n simple entre p√°ginas -->
  <header style="text-align:center; margin-bottom:18px;">
    <nav>
      <a href="index.html">Inicio</a> |
      <a href="registro.html">Registro</a> |
      <a href="login.html">Login</a> |
      <a href="citas.html">Citas</a> |
      <a href="panel.html">Panel</a>
    </nav>
  </header>

  <div class="container">
    <div class="card">
      <div class="two-col">
        <div class="col">
          <h1>üíà Tus Citas</h1>
        </div>
        <div class="col text-center">
          <!-- Bot√≥n para cerrar sesi√≥n del usuario (usa supabase.auth) -->
          <button id="logoutBtn">Cerrar sesi√≥n</button>
        </div>
      </div>

      <!-- Formulario para reservar una cita. Se valida en cliente y se env√≠a a la tabla `citas` en Supabase -->
      <form id="formCita" class="form-inner">
        <input type="text" id="nombre" placeholder="Tu nombre" required />
        <input type="text" id="telefono" placeholder="Tel√©fono" required />
        <!-- Selector de barbero: se llena din√°micamente desde la tabla `barberos` -->
        <select id="barbero" required>
          <option value="">Selecciona un barbero</option>
        </select>

        <!-- Servicios predefinidos -->
        <select id="servicio" required>
          <option value="">Selecciona un servicio</option>
          <option value="Corte de cabello">Corte de cabello</option>
          <option value="Arreglo de barba">Arreglo de barba</option>
          <option value="Corte + Barba">Corte + Barba</option>
        </select>

        <!-- Fecha de la cita (YYYY-MM-DD) -->
        <input type="date" id="fecha" required />

        <!-- Selector de hora: opciones cada 30 minutos seg√∫n el horario del barbero -->
        <select id="hora" required>
          <option value="">Selecciona una hora</option>
        </select>
        <button type="submit">Reservar</button>
      </form>

      <h2>Citas registradas</h2>
      <!-- Aqu√≠ se listan las citas del usuario autenticado -->
      <div id="listaCitas" class="citas-list"></div>
    </div>
  </div>

  <script>
    /*
      Conexi√≥n a Supabase
      - SUPABASE_URL y SUPABASE_KEY vienen del proyecto Supabase.
      - No es seguro poner keys p√∫blicas en producci√≥n; para este ejemplo asumimos un proyecto de aprendizaje.
    */
    const SUPABASE_URL = "https://rxhdeyvakjdwtlqtvnak.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ4aGRleXZha2pkd3RscXR2bmFrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwODU0NTgsImV4cCI6MjA3NjY2MTQ1OH0.qby_C9hC-eQ2juVPU2EUggWI01lG0HJU0tvmbdJ7Iu8";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);


    // =====================
    // Funciones principales
    // =====================

    // cargarBarberos
    // - Lee la tabla `barberos` y pobla el select #barbero.
    // - Guarda informaci√≥n relevante en `dataset` de cada <option> para uso posterior
    // Entrada: ninguna
    // Salida: modifica el DOM (select #barbero)
    // Errores: escribe en consola si la consulta falla
    async function cargarBarberos() {
      const { data: barberos, error } = await supabase
        .from("barberos")
        .select("id, nombre, horario_inicio, horario_fin, dias")
        .order("nombre", { ascending: true });

      if (error) return console.error("Error al cargar barberos:", error);

      const sel = document.getElementById("barbero");
      sel.innerHTML = '<option value="">Selecciona un barbero</option>';
      barberos.forEach(b => {
        const opt = document.createElement("option");
        opt.value = b.id;
        // Mostrar nombre y horario si existe
        opt.text = b.horario_inicio && b.horario_fin
          ? `${b.nombre} (${b.horario_inicio} - ${b.horario_fin})`
          : b.nombre;
        // Guardar horarios y d√≠as en dataset para validaciones posteriores
        opt.dataset.inicio = b.horario_inicio || ""; // ejemplo: "09:00:00"
        opt.dataset.fin = b.horario_fin || "";       // ejemplo: "18:00:00"
        opt.dataset.dias = b.dias || ""; // ejemplo: "1,2,3,4,5"
        sel.appendChild(opt);
      });
    }

    // Al cambiar el barbero seleccionado:
    // - Se generan las opciones de hora en base al horario guardado en dataset
    // - Se limpia la fecha y se deshabilita el bot√≥n de submit hasta tener fecha y hora v√°lidas
    document.getElementById("barbero").addEventListener("change", (e) => {
      const selected = e.target.selectedOptions[0];
      const horaSelect = document.getElementById("hora");
      if (selected && selected.dataset.inicio) {
        // dataset almacena horarios como HH:MM:SS, slice(0,5) ‚Üí HH:MM
        const inicio = (selected.dataset.inicio || '').slice(0,5);
        const fin = (selected.dataset.fin || '').slice(0,5);
        // Poblar inicialmente con todos los slots del rango (sin comprobar reservas)
        populateHoraOptions(inicio, fin);
        // Almacenamos tambi√©n los d√≠as en el select de horas para validar despu√©s
        horaSelect.dataset.dias = selected.dataset.dias || '';
        // Limpiar fecha para forzar re-selecci√≥n y validaci√≥n por d√≠a
        document.getElementById('fecha').value = '';
        // Deshabilitar submit hasta que el usuario elija fecha y hora v√°lidas
        document.querySelector('#formCita button[type=submit]').disabled = true;
      } else {
        // Si no hay horario, deshabilitar selector de hora
        horaSelect.innerHTML = '<option value="">Selecciona una hora</option>';
        horaSelect.disabled = true;
      }
    });

    // Al cambiar la fecha:
    // - Verifica si el barbero trabaja ese d√≠a (si tiene `dias` configurado)
    // - Consulta las citas existentes para esa fecha y barbero y filtra las horas ya reservadas
    document.getElementById('fecha').addEventListener('change', async (e) => {
      const fecha = e.target.value; // formato YYYY-MM-DD
      // Evitar fechas anteriores a hoy
      const todayStr = new Date().toISOString().slice(0,10);
      if (fecha && fecha < todayStr) {
        alert('No puedes elegir una fecha anterior a hoy.');
        e.target.value = '';
        document.querySelector('#formCita button[type=submit]').disabled = true;
        return;
      }
      const barberoSel = document.getElementById('barbero').selectedOptions[0];
      if (!barberoSel) return alert('Selecciona un barbero primero');

      // `dias` es una cadena como "1,2,3" donde 1=Lunes ... 7=Domingo
      const dias = (barberoSel.dataset.dias || '').split(',').map(s => s.trim()).filter(Boolean);
      if (dias.length > 0) {
        // new Date(...).getDay() devuelve 0=Domingo..6=S√°bado. Convertimos a 1..7
        const day = new Date(fecha + 'T00:00:00').getDay();
        const dayNum = day === 0 ? 7 : day; // 1=Lun .. 7=Dom
        if (!dias.includes(String(dayNum))) {
          // Si el barbero no trabaja ese d√≠a, avisamos y limpiamos la fecha
          alert('El barbero no trabaja ese d√≠a. Elige otra fecha.');
          e.target.value = '';
          document.querySelector('#formCita button[type=submit]').disabled = true;
          return;
        }
      }

      // Obtener horas totales del barbero desde dataset
      const inicio = (barberoSel.dataset.inicio || '').slice(0,5);
      const fin = (barberoSel.dataset.fin || '').slice(0,5);
      if (!inicio || !fin) return;

      // Generamos todos los slots y luego quitamos los que ya est√©n reservados
      const allSlots = generateSlots(inicio, fin);
      // Consultar citas existentes para este barbero y fecha
      const { data: citasExistentes, error } = await supabase.from('citas')
        .select('hora')
        .eq('barbero_id', parseInt(barberoSel.value,10))
        .eq('fecha', fecha);
      let reserved = [];
      if (!error && citasExistentes) reserved = citasExistentes.map(c => c.hora.slice(0,5)); // 'HH:MM:SS' -> 'HH:MM'

      // Poblar select de horas con las horas libres
      const horaSelect = document.getElementById('hora');
      horaSelect.innerHTML = '<option value="">Selecciona una hora</option>';
      allSlots.forEach(s => {
        if (!reserved.includes(s)) {
          const opt = document.createElement('option');
          opt.value = s;
          opt.text = s;
          horaSelect.appendChild(opt);
        }
      });

      // Habilitar submit s√≥lo si hay al menos una hora disponible
      document.querySelector('#formCita button[type=submit]').disabled = horaSelect.options.length <= 1;
    });


    /*
      generateSlots(inicio, fin)
      - Entrada: inicio y fin en formato 'HH:MM' (ej. '09:00')
      - Salida: array de strings con slots cada 30 minutos: ['09:00', '09:30', ...]
      - Nota: devuelve slots inclusivos desde inicio hasta fin-30min. No modifica el DOM.
    */
    function generateSlots(inicio, fin) {
      const toMinutes = t => {
        const [hh, mm] = t.split(':').map(Number);
        return hh * 60 + mm;
      };
      const toTime = m => `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`;
      const start = toMinutes(inicio);
      const end = toMinutes(fin);
      const slots = [];
      // Iterar en pasos de 30 minutos
      for (let mins = start; mins <= end - 30; mins += 30) slots.push(toTime(mins));
      return slots;
    }

    // populateHoraOptions(inicio, fin)
    // - Llena el <select id="hora"> con opciones cada 30 minutos entre inicio y fin.
    function populateHoraOptions(inicio, fin) {
      const horaSelect = document.getElementById('hora');
      horaSelect.disabled = false;
      horaSelect.innerHTML = '<option value="">Selecciona una hora</option>';
      if (!inicio || !fin) return;

      const toMinutes = t => {
        if (!t) return null;
        const [hh, mm] = t.split(':').map(Number);
        return hh * 60 + mm;
      };
      const toTime = m => {
        const hh = Math.floor(m / 60) % 24;
        const mm = m % 60;
        return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
      };

      const start = toMinutes(inicio);
      const end = toMinutes(fin);
      if (start === null || end === null || end <= start) return;

      for (let mins = start; mins <= end - 30; mins += 30) {
        const t = toTime(mins);
        const opt = document.createElement('option');
        opt.value = t;
        opt.text = t;
        horaSelect.appendChild(opt);
      }
    }

    // getUser
    // - Obtiene el usuario autenticado desde Supabase
    // - Si no hay usuario autenticado, redirige a login.html
    async function getUser() {
      const { data } = await supabase.auth.getUser();
      if (!data.user) window.location.href = "login.html"; // forzar login
      return data.user;
    }

    // cargarCitas(user)
    // - Carga las citas del usuario autenticado y las muestra en la UI
    async function cargarCitas(user) {
      const { data } = await supabase.from("citas").select("*").eq("user_id", user.id).order("fecha", { ascending: true });
      const lista = document.getElementById("listaCitas");
      lista.innerHTML = "";
      // Mostrar cada cita en un bloque sencillo
      data.forEach(c => {
        const div = document.createElement("div");
        div.className = "cita";
        // Mostrar los datos principales dentro de un contenedor para permitir separar el bot√≥n
        // A√±adimos tambi√©n una badge que indica el estado (pendiente/finalizada)
        const estadoBadge = c.finalizada ? '<span class="badge completed">Finalizada</span>' : '<span class="badge pending">Pendiente</span>';
        div.innerHTML = `<div class="cita-info"><strong>${c.servicio}</strong> ${estadoBadge}<br>üìÖ ${c.fecha} ‚è∞ ${c.hora}<br>üìû ${c.telefono}</div>`;

        // S√≥lo mostrar bot√≥n 'Cancelar' si la cita NO est√° finalizada
        if (!c.finalizada) {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'secondary'; // usa estilo secundario definido en CSS
          btn.textContent = 'Cancelar';
          // Al hacer click: confirmar y eliminar la cita en la tabla `citas`
          btn.addEventListener('click', async () => {
            const ok = confirm('¬øSeguro que quieres cancelar esta cita?');
            if (!ok) return;
            btn.disabled = true;
            // A√±adimos tambi√©n el filtro por user_id para mayor seguridad: solo el due√±o puede borrar
            const { error } = await supabase.from('citas').delete().eq('id', c.id).eq('user_id', user.id);
            if (error) {
              alert('‚ùå Error al cancelar la cita: ' + error.message);
              btn.disabled = false;
            } else {
              alert('‚úÖ Cita cancelada');
              // refrescar la lista de citas para el usuario
              cargarCitas(user);
            }
          });
          div.appendChild(btn);
        }
        lista.appendChild(div);
      });
      // Iniciar polling que revisa si alguna cita se marc√≥ finalizada y notifica al usuario
      startFinalizadaPolling(user.id);
    }

    // Polling simple mejorado: cada 10s comprobamos nuevas citas finalizadas
    // - Almacena en localStorage los IDs ya notificados para evitar repetir alertas
    // - Agrupa varias finalizaciones en una sola alerta para evitar saturar al usuario
    let _pollInterval = null;

    function _getNotifiedFinalizadas(userId) {
      try {
        const key = `notifiedFinalizadas_${userId}`;
        const raw = localStorage.getItem(key);
        if (!raw) return new Set();
        const arr = JSON.parse(raw);
        return new Set(Array.isArray(arr) ? arr : []);
      } catch (e) {
        console.error('Error leyendo notifiedFinalizadas:', e);
        return new Set();
      }
    }

    function _saveNotifiedFinalizadas(userId, set) {
      try {
        const key = `notifiedFinalizadas_${userId}`;
        localStorage.setItem(key, JSON.stringify(Array.from(set)));
      } catch (e) {
        console.error('Error guardando notifiedFinalizadas:', e);
      }
    }

    function startFinalizadaPolling(userId) {
      if (_pollInterval) clearInterval(_pollInterval);
      // Ejecutar inmediatamente y luego cada 10s
      const runOnce = async () => {
        try {
          const { data, error } = await supabase.from('citas').select('id, servicio, fecha, hora, finalizada').eq('user_id', userId).eq('finalizada', true);
          if (error) return console.error('Error al comprobar finalizadas:', error.message || error);

          const notified = _getNotifiedFinalizadas(userId);
          // Filtrar s√≥lo las finalizadas que a√∫n NO hemos notificado
          const nuevas = (data || []).filter(c => !notified.has(String(c.id)));
          if (nuevas.length > 0) {
            // Agrupar en una sola notificaci√≥n (mejor UX que m√∫ltiples alertas)
            const lines = nuevas.map(c => `- ${c.servicio} (${c.fecha} ${c.hora})`);
            alert(`Las siguientes citas han sido marcadas como finalizadas:\n\n${lines.join('\n')}`);

            // Marcar como notificadas
            nuevas.forEach(c => notified.add(String(c.id)));
            _saveNotifiedFinalizadas(userId, notified);

            // Refrescar la lista de citas para mostrar los badges actualizados
            const user = await getUser();
            cargarCitas(user);
          }
        } catch (e) {
          console.error('Polling finalizadas error:', e);
        }
      };

      // Primera ejecuci√≥n inmediata
      runOnce();
      _pollInterval = setInterval(runOnce, 10000);
    }

    // Env√≠o del formulario de cita
    // - Valida que el usuario y los campos requeridos existan
    // - Inserta la nueva fila en la tabla `citas`
    document.getElementById("formCita").addEventListener("submit", async (e) => {
      e.preventDefault();
      const user = await getUser(); // redirige a login si no est√° autenticado
      const barberoId = e.target.barbero.value;
      if (!barberoId) return alert("Selecciona un barbero");
      const fecha = e.target.fecha.value;
      const hora = e.target.hora.value;
      // Validar fecha y hora
      if (!fecha || !hora) return alert('Selecciona fecha y hora v√°lidas');
      const today = new Date().toISOString().slice(0,10);
      if (fecha < today) return alert('No puedes reservar una fecha anterior a hoy');

      // Comprobar si ya existe una cita para ese barbero/fecha/hora (evitar duplicados)
      const { data: existingCitas, error: errExist } = await supabase.from('citas').select('hora').eq('barbero_id', parseInt(barberoId,10)).eq('fecha', fecha);
      if (!errExist && existingCitas) {
        const reserved = existingCitas.map(c => (c.hora || '').slice(0,5));
        if (reserved.includes(hora)) return alert('‚ö†Ô∏è Ese horario ya est√° reservado. Elige otra hora.');
      }

      const nueva = {
        user_id: user.id,
        barbero_id: parseInt(barberoId, 10),
        nombre: e.target.nombre.value,
        telefono: e.target.telefono.value,
        servicio: e.target.servicio.value,
        fecha: fecha,
        hora: hora,
      };

      // insertar en Supabase
      const { error } = await supabase.from("citas").insert([nueva]);
      if (error) alert(error.message);
      else {
        alert("‚úÖ Cita registrada");
        // refrescar lista y limpiar formulario
        cargarCitas(user);
        e.target.reset();
      }
    });

    // Bot√≥n de logout: cierra la sesi√≥n en Supabase y redirige a login
    document.getElementById("logoutBtn").addEventListener("click", async () => {
      await supabase.auth.signOut();
      window.location.href = "login.html";
    });

    // Al cargar la p√°gina: primero cargamos barberos y luego, si el usuario est√° autenticado, sus citas
    cargarBarberos().then(() => {
      getUser().then(cargarCitas);
    });
  </script>
</body>
</html>
